\chapter{Singleton}

\section{Allgemeine Informationen}

"Singelton" ist ein Entwurfsmuster das dafür sorgt, dass es nur eine Instanz einer Klasse gibt. Auf diese kann global zugegriffen werden und durch den privaten Konstruktor wird verhindert, dass andere Klassen weitere Instanzen erstellen können.
\\
\\
Die Singleton-Klasse umfasst daher einen privaten Konstruktor, einen Kopierkonstruktor, einen Zeiger auf die einzigartige Instanz und natürlich den Destruktor. Nur eine Methode ist öffentlich, die "GetInstanz"-Methode.
\\
\\
Es gibt viele verschiedene Implementationen des Musters. Wir haben uns für diese Variante entschieden. Besonders muss zwischen zwei Versionen des Musters unterscheiden werden. Es gibt eine Eager- und eine Lazy Version.
\\
\\
Bei der "Eager Loading" Version findet das Erzeugen der Instanz beim Laden der Klasse statt. Vorteile sind hier die Einfachheit und die Threadsicherheit. Jedoch gibt es auch Nachteile. Durch eine verfrühte Erzeugung können Probleme entstehen. Wenn vor der Initialisierung Informationen benötigt werden kann es zu Problemen kommen. Auch eine zu frühe Erzeugung bei ressourcenintensiven Singelton kann Probleme machen.
\\
\\
Man sieht, dass die Eager Loading Version nur dann sinnvoll ist, wenn es sich um eine kleine Singleton Klasse handelt.
\\
\\
Gegenteilig verhält sich die "Lazy Loading" Variante des Singleton Musters. Hier wird die Instanz erst beim ersten Aufruf erzeugt. Die Methode GetInstance überprüft, ob bereits eine Instanz erzeugt wurde und erstellt für den Fall, dass es keine gibt, eine neue. Falls es bereits eine Instanz gibt wird diese zurückgegeben.
\\
\\
Ein Problem bei dieser Methode ist die Threadsicherheit. Diese ist nicht mehr gegeben. \\

Es folgt ein Beispiel für eine Implementation des Singleton Patterns von Scott Meyers, bei dem auch das Objekt beim Ende des Programms zerstört wird:
\begin{lstlisting}

class Singleton
{
private:
    // Standard- und Copykonstruktor sowie Destruktor sind private. 
    // Nur Methoden dieser Klasse koennen auf sie 
    // zugreifen.
    Singleton() {};
    Singleton(const Singleton&);
    ~Singleton();

    // Es gibt nur eine Instanz. Jede Zuweisung waere
    // eine Selbstzuweisung.
    // Da Selbstzuweisungen selten Sinn machen, ist
    // der op= privat
    Singleton& operator=(const Singleton&);
public:
    // Diese statische Methode erzeugt die einzige
    // Instanz.
    // Nur ueber diese Methode erhalten Anwender den 
    // Zugriff auf die Instanz.
    static Singleton& GetInstance() 
    {
        // Die Instanz wird erst beim ersten Aufruf
        // erzeugt.
        // Endet das Programm, wird Instanz vernichtet.
        static Singleton Instance;
        return Instance;
    }
};
\end{lstlisting}

Natürlich kann man sich auch für eine andere Art von Singelton entscheiden, jedoch ist dies eine sehr einfache Art, das Singelton Pattern umzusetzen.
\cite{singelton}\cite{singelton2}
\section{Umsetzung}

Wenn der Entwickler ein UML-Diagramm in Rhapsody zeichnet und dabei eine bestimmte Klasse als Singleton implementieren möchte, setzt er bei dieser Klasse den Stereotype als Singleton. Möchte der Entwickler nun aus diesem Diagramm Code generieren, wird von Rhapsody wie in Kapitel 1 - Aufgabenbeschreibung erläutert Java-Klassen aufgerufen, die diese Klasse dann als Singleton Klasse in C++-Code erzeugen. 
\\
Hierbei wird als erstes der Konstruktor und der Kopierkonstruktor auf private gesetzt, da weder von "außerhalb" keine Instanz direkt über den new-Operator erzeugt werden kann, noch ein Objekt kopiert werden soll. Möchte man ein Objekt der Klasse angelegt werden soll, muss dies über die GetInstanz Methode geschehen. In dieser Methode wird zunächst geprüft ob es schon eine Instanz gibt, ist dies der Fall wird diese Instanz genutzt, wenn nicht wird eine neue Instanz erzeugt.

