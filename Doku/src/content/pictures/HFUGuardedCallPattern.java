

package com.ibm.rhapsody.samples.cppUserSimplifiers.simplifiers;

import java.util.List;

import com.ibm.rhapsody.samples.cppUserSimplifiers.utils.Reporter;
import com.telelogic.rhapsody.core.IRPArgument;
import com.telelogic.rhapsody.core.IRPAttribute;
import com.telelogic.rhapsody.core.IRPClass;
import com.telelogic.rhapsody.core.IRPCollection;
import com.telelogic.rhapsody.core.IRPModelElement;
import com.telelogic.rhapsody.core.IRPOperation;
import com.telelogic.rhapsody.core.IRPStereotype;

public class HFUGuardedCallPattern extends AbstractSimplifier {

	protected boolean doesApplyFor(IRPModelElement userElement) {
		return userElement instanceof IRPClass;
	}

	@Override
	protected void onAbortSimplification() {
	}

	@Override
	protected void onBeginSimplification() {
	}

	@Override
	protected void onEndSimplification() {
	}

	@Override
	protected void onExitSimplification() {
	}

	@Override
	protected void onSimplify(IRPModelElement userElement, IRPModelElement simplifiedElementOwner, String simplificationRequested) {
	}

	/**
	 * 
	 * Methode fuehrt Transformation der uebergebenen Klasse durch,
	 * Vorraussetzungen werden geprueft
	 * 
	 * @param userClass
	 *            - Die Klasse, welche transformiert werden soll
	 * @param mainSimplifiedElement
	 *            - Klasse welche waehrend der Code-Generation erzeugt wird.
	 * 
	 */
	// protected void onPostSimplification( IRPModelElement userClass,
	// IRPModelElement mainSimplifiedElement, String simplificationRequested )
	// {
	// guardedCallexists(userClass, mainSimplifiedElement);
	// }
	//
	// @SuppressWarnings("unchecked")
	// private void guardedCallexists(IRPModelElement userElement,
	// IRPModelElement mainSimplifiedElement) {
	// if ((userElement instanceof IRPClass)) {
	// List<IRPStereotype> stereotypes = userElement.getStereotypes().toList();
	// for (IRPStereotype stereotype : stereotypes) {
	// String stereotypeName = stereotype.getName();
	// if (stereotypeName.compareTo("TODO") == 0) {
	// //Rountrip pruefen
	// simplifyGuardedCall((IRPClass) mainSimplifiedElement);
	// }
	// }
	// }
	// }

	private final String MUTEX_NAME = "mutex";
	private final String GUARDED_METHOD_SUFFIX = "Guarded";

	private String errorMessage = "";

	Roundtrip roundTrip = new Roundtrip();
	ErrorHandling errorHandling= new ErrorHandling();
	
	private String getMutexName() {
		return MUTEX_NAME;
	}

	private String getGuardedMethodName(String originalName) {
		return originalName + GUARDED_METHOD_SUFFIX;
	}

	protected void onPostSimplification(IRPModelElement userClass, IRPModelElement mainSimplifiedElement, String simplificationRequested) {
		Reporter.report("\n\n");
		Reporter.report("# User Simplification gestartet");

		if (hasStereotype(userClass)) {
			simplifyToGuardedCallPattern((IRPClass) mainSimplifiedElement);
		}
		
		Reporter.report("errors: " + errorMessage);
		
		if(errorMessage.length() > 5){
			Reporter.report("length > 0");
			errorHandling.ClassenthaeltFehler((IRPClass) mainSimplifiedElement, errorMessage);
		}
	}

	@SuppressWarnings("unchecked")
	private boolean hasStereotype(IRPModelElement userElement) {
		if ((userElement instanceof IRPClass)) {
			
			List<IRPStereotype> stereotypes = userElement.getStereotypes().toList();
			for (IRPStereotype stereotype : stereotypes) {
				if (stereotype.getName().compareTo("GuardedCall") == 0)
					return true;
			}
		}

		return false;
	}

	@SuppressWarnings("unchecked")
	private void simplifyToGuardedCallPattern(IRPClass toGuardedCall) {
		if (toGuardedCall != null) {
			Reporter.report("## Klasse >>" + toGuardedCall.getName() + "<< wird simplifiziert");

			// Mutex-Objekt Ueberpruefen bzw erstellen

			List<IRPAttribute> attributes = toGuardedCall.getAttributes().toList();
			boolean mutexAlreadyAddedByUser = false;

			for (IRPAttribute attribute : attributes) {
				Reporter.report("Name: " + attribute.getName());
				Reporter.report("Desc: " + attribute.getDescription());
				
				if (attribute.getName().equals(getMutexName())) {
					Reporter.report("getName() == mutexName");
					
					if (roundTrip.findAttribute("Generated by HFUSimplifier", attribute)) {
						Reporter.report("comment found");
						
						toGuardedCall.deleteAttribute(attribute);
					} else {
						Reporter.report("### Attribut mutex bereits vorhanden!!!");
						errorMessage = "Attribut mutex bereits vorhanden";
						mutexAlreadyAddedByUser = true;
					}
				}
			}
			if (!mutexAlreadyAddedByUser) {
				Reporter.report("createMutexObject");
				createMutexObject(toGuardedCall);
			}

			// Methoden anpassen
			List<IRPOperation> operations = toGuardedCall.getOperations().toList();
			for (IRPOperation operation : operations) {
				Reporter.report("operation " + operation.getName());

				// Mutex init Ueberpruefen bzw erstellen
				if (operation.getIsCtor() == 1) {
					if (!roundTrip.findComment("Generated by HFUSimplifier", operation)) {
						createMutexInit(operation);
					}
				}

				if (!(operation.getIsCtor() == 1 || operation.getIsDtor() == 1)) {
					if (!roundTrip.findComment("Generated by HFUSimplifier", operation)) {
						String originalName = operation.getName();
						String visibility = operation.getVisibility();
						String returnType = operation.getReturnTypeDeclaration();
						String code = operation.getBody();
						IRPCollection arguments = operation.getArguments();
						
						operation.setName(getGuardedMethodName(originalName));
						operation.setVisibility("private");
						operation.setBody("//Generated by HFUSimplifier \n" + code);
						
						createWrapperMethod(toGuardedCall, originalName, visibility, returnType, arguments);
					}
				}
			}
		}
	}

	private void createMutexInit(IRPOperation operation) {
		String code = operation.getBody();
		String newCode = "mutex = OMOSFactory::instance()->createOMOSMutex();\n" + code;
		operation.setBody("//Generated by HFUSimplifier \n" + newCode);
	}

	private void createMutexObject(IRPClass toGuardedCall) {
		IRPAttribute mutexObject = toGuardedCall.addAttribute("mutex");
		mutexObject.setVisibility("private");
		mutexObject.setDescription("Generated by HFUSimplifier");
		mutexObject.setTypeDeclaration("OMOSMutex*");
		mutexObject.setPropertyValue("CPP_CG.Attribute.InitializationStyle", "ByAssignment");
		mutexObject.setIsStatic(0);
	}

	private void createWrapperMethod(IRPClass toGuardedCall, String methodName, String visibility, String returnType, IRPCollection arguments) {

		IRPOperation wrapperMethod = toGuardedCall.addOperation(methodName);
		wrapperMethod.setVisibility(visibility);
		wrapperMethod.setReturnTypeDeclaration(returnType);
		wrapperMethod.setIsStatic(0);
		
		List<IRPArgument> argumentList = arguments.toList();
		
		String args = "";
		
		for (IRPArgument argument : argumentList) {
			String name = argument.getName();
			String declaration = argument.getDeclaration();
			
			wrapperMethod.addArgument(name);
			
			List<IRPArgument> ar2 = wrapperMethod.getArguments().toList();
			
			for (IRPArgument a : ar2) {
				if (a.getName().equals(name)) {
					a.setDeclaration(declaration);
				}
			}
			
			if (args.length() > 2) args += ", ";
			args += name;
		}
		
		Reporter.report(args);

		boolean isVoidMethod = returnType.equals("void");

		// Body erstellen
		String methodContent = getMutexName() + "->lock();\n";
		if (!isVoidMethod)
			methodContent += returnType + " temp;\n";
		methodContent += "try {\n";
		if (!isVoidMethod)
			methodContent += "temp = ";
		methodContent += getGuardedMethodName(methodName) + "(";
		
		methodContent += args;
	
		methodContent += ");\n" + "} catch (...) {\n" + getMutexName() + "->unlock();\n" + "throw;\n" + "}\n"
				+ getMutexName() + "->unlock();\n";
		if (!isVoidMethod)
			methodContent += "return temp;";

		wrapperMethod.setBody("//Generated by HFUSimplifier \n" + methodContent);
	}
}
